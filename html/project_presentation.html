<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>liblooklike: Parallelization and OpenCL : an example with facial recognition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">liblooklike
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Parallelization and OpenCL : an example with facial recognition </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>A short presentation of parallelization</h2>
<p>The word parallelization is becoming very common in Computer Science, and has spread outside laboratories. Intense computation tasks are widely used in various domains outsides science : games, picture editing, pattern recognition...</p>
<p>To simplify, we can consider two of the fields of study in computer science:</p><ul>
<li>the improvement of computer performances</li>
<li>the design of more optimized algorithms.</li>
</ul>
<p>Parallelization bridges both of these orientations. It addresses the limitation of the standard computers by multiplying the computation devices inside the machine, but requires specifically designed algorithms, that can split work among the devices instead of queuing tasks on a single one. Thus if you replicate six times your computation devices and split work equally between each one, you can expect a performance improvement by a factor up to six.</p>
<p>Figure [] shows the difference between sequential, and parallel execution.</p>
<p>Further in this series of tutorials, we shall call computation device the object that takes data input, executes a computation on it and returns the result of the algorithm. Parallelization will happen inside this computation device.</p>
<p>If the problem of parallelization is indeed to create a compatible algorithm, the existence of physical architectures providing the assets to run the programs is in fact quite recent. The first solution was to build a pool of computers inside a network, and develop a software layer on top to synchronize tasks and memory operations.</p>
<p>Graphic cards have lately come into the field of computation devices.They actually are all-in-one parallel computation devices boasting several thousands of microprocessors optimised for float computation and several types of memory. They provide higher computation efficiency than a classical CPU which is designed for more complex tasks.</p>
<h2>Parallelization with OpenCL</h2>
<p>The diversity of graphic cards and more generally of devices with parallelization abilities is wide. As a consequence, a uniform programming interface had to be designed in order to provide a common standard for parallel computation. This enables developers to provide a single code that can be run on a wide range of devices.</p>
<p>The solution we shall explore here is called OpenCL, but this is not the only one (CUDA (tm) is another example). OpenCL objects names will be used, but most concepts are shared across the different parallelized environments.</p>
<p>OpenCL is a specification. This specification was not published by a graphic card manufacturer, but rather by the Chronos Group who designed it and has had a long relationship with the graphic cards market.</p>
<p>Being a specification, it only defines a set of functions with a description of the expected behaviour. The purpose of these functions is to handle the operations needed to execute a computation on a device. Thus you can find functions ranging from devices listing to data and programs loading. As of now, the specification has been implemented by the main desktop computer part makers, but also for high end embedded devices such as cellphones. The libraries however do not always implement all the functionalities of the specification.</p>
<h2>Implementation of parallelization : the overall process as defined in OpenCL</h2>
<p>The OpenCL specification divides the computation process into several parts. We shall present each of them below, and introduce the naming convention used in the specification.</p>
<h3>Choosing a platform</h3>
<p>The specification is implemented into a library, that is to say a piece of computer program running on both the computer and the computation device. The first step is to choose which platform implementation will be used if several ones are available. Since most computation devices manufacturer provide a library for their own devices, you usually end up choosing the library that matches the devices on which we want to work.</p>
<p>Ex: If you wish to work with an AMD graphic card, you will want to use AMD\'s OpenCL implementation.</p>
<p>Note that a platform can handle multiple devices at the time, provided that all of them are supported by the implementation. Thus you can imagine a computation device that is actually an aggregation of several identical graphic cards.</p>
<h3>Starting a context</h3>
<p>A context has several roles, it manages memory buffers, devices and command queues. The context in a Object oriented programming point of view is what matches best what we have called computation device so far. It is the root object during the whole computation process.</p>
<p>The context is usually created from a list of devices listed by the platform selected during the previous step.</p>
<h3>Allocating memory</h3>
<p>The memory model of OpenCL is more complicated than in a standard computer. For example, data can be split or shared implicitly between devices. More generally there is an abstraction layer between the real memory management inside the computation device and the OpenCL interface. The purpose of this complex system is to make parallelization possible in the device without low level hardware considerations, as everything is automatically handled by the OpenCL implementation. Data transfers between the computer program and the computation devices is manual though. And the user has to put transfer orders in the command queues.</p>
<p>Manipulating memory through the abstract layer is achieved by representing memory blocks by buffer objects. One should dig further the comprehension of the graphic cards memory models in order to optimize the configuration of these buffers, but this is not the purpose of this document.</p>
<h3>Creating a command queue</h3>
<p>For the same reasons that motivated the creation of a memory abstraction layer, it is not possible to write a program that gets executed by the computation device directly. OpenCL uses a command queuing mechanism instead.</p>
<p>A queue holds orders for the operations to be executed:</p><ul>
<li>data load</li>
<li>program execution</li>
<li>data retrieval</li>
</ul>
<p>At this point, you might still wonder how parallelization happens in the OpenCL representation of a computation. It is achieved through the use of the command queues, and more specifically the program execution order.</p>
<p>Let\'s use the typical example of unrolling a loop in order to make a parallelized computation. If we take the following sequential pseudo-code example : </p><pre class="fragment">for i in range 1 to 10 
    compute f(i)
end 
</pre><p>OpenCL offers a range based parallelization. The OpenCL program will look similar to this pseudo-code: </p><pre class="fragment">create R a series of values in range 1 to 10 
enqueue computation of f(x) for each x element of R 
wait for the end of computation event 
retrieve results. 
</pre><p>At line 2, the computation device will start independent threads each evaluating f(x) with a different x parameter.</p>
<p>Please, bare in mind that OpenCL specification imposes no constraint as of the order in which threads are started. Thus writing in shared memory requires specific locking and synchronisation systems.</p>
<p>OpenCL parallelization is always range-based, so there is a range object. It is possible to specify up to 3 ranges of values for a single computation which is useful for algorithms running on a discrete space problem.</p>
<h3>Enqueuing data load and program execution</h3>
<p>Since the kernels are executed without specific order, OpenCL offers a mechanism to handle the order end the execution of tasks. Every OpenCL operation is stored in a command queue and each event has an associated end event.</p>
<p>Commands in the queue are executed as soon as possible with respect to other events if dependencies are specified between commands.</p>
<h2>OpenCL in LibLookLike</h2>
<p>This project tries to simplify the integration of OpenCL and hence offers a wrapper around the OpenCL library in order to simplify the work of creating OpenCL accelerated algorithm.</p>
<p>A platform is automatically chosen with various sanity checks. Loading kernels and handling dependencies is done transparently thanks to a framework that standardizes algorithms and mathematical objects writing.</p>
<h2>Computation tree : expressions, operators and sets</h2>
<p>When we conceive a sequential algorithm, all functions are blocking the execution flow until the instructions are completed. In the case of concurrent execution, a function is applied simultaneously to an array of values. However, the execution of single instances of the function is not synced between each process. One function instance might finish its work before another one.</p>
<p>If you consider a sequence of operations such as the evaluation of a mathematical expression, it appears that some instructions cannot be started until the result of another is available.</p>
<p>Example:</p>
<p>In \(a * ( b + c )\), \(( b + c )\) must be computed before the product operation can start.</p>
<p>In LibLookLike, the operations are represented as a tree : the leaves of the tree are expressions and the nodes are operators. Each expression is of a certain type, or set : it can be a scalar value, a matrix, a vector, etc...</p>
<p>The tree evaluation is performed recursively and automates the following tasks:</p><ul>
<li>memory allocation for the leaves concerned by the same operator</li>
<li>memory allocation for the result(s) and temporary memory if needed</li>
<li>execution of the operation.</li>
</ul>
<p>When an operation is executed, the node representing the operation has a new leaf storing the expression corresponding to the result of the operation.</p>
<p>The evaluation of a whole computation tree is performed by the operators and works recursively. This means if a root operation has dependencies which require computation, it will start evaluation on the root operation of the dependencies which in turn will perform the necessary tasks to compute their resulting expressions.</p>
<h2>Expressions and operators : <a class="el" href="classExpression.html" title="Expression object as defined in Expression. ">Expression</a> and <a class="el" href="classAlgorithm.html" title="Algorithms class as described in Algorithm. ">Algorithm</a> classes</h2>
<h3><a class="el" href="classExpression.html" title="Expression object as defined in Expression. ">Expression</a></h3>
<p>Expressions in LibLookLike are represented by the class <a class="el" href="classExpression.html" title="Expression object as defined in Expression. ">Expression</a>, which is an abstract class defining a set of common characteristics. When evaluating an expression, the operation attached to the expression will start its execution. If no operation is attached to an expression, it means that the expression does not need to be computed.</p>
<h3><a class="el" href="classAlgorithm.html" title="Algorithms class as described in Algorithm. ">Algorithm</a></h3>
<p>Operations in LibLookLike are represented by the class <a class="el" href="classAlgorithm.html" title="Algorithms class as described in Algorithm. ">Algorithm</a>, which is a standardized interface on the operations. The <a class="el" href="classAlgorithm.html" title="Algorithms class as described in Algorithm. ">Algorithm</a> class automates the memory allocations, dependencies and execution for the computation of expressions.</p>
<p>An algorithm takes expressions in and yields results which are expressions themselves. The input is also considered as dependencies of the algorithm.</p>
<p>When executing an operation, if the input values are not yet evaluated, it will automatically start their evaluation. Then the actual computation performed by the operation will start.</p>
<h3>Interactions between <a class="el" href="classExpression.html" title="Expression object as defined in Expression. ">Expression</a> and <a class="el" href="classAlgorithm.html" title="Algorithms class as described in Algorithm. ">Algorithm</a></h3>
<p>The method getResult() (or an equivalent function depending on the algorithm) applied on a algorithm returns an expression, not yet computed, but related to this algorithm. Then, with such an expression as input, it is possible to create other operations. Calling getResult() on these operations will return expressions whose actual value is still unknown. A call to the method evaluate() will fill the expression with its actual value, after all the dependencies of this expression have been evaluated recursively.</p>
<h2>Facial recognition and parallelization in LibLookLike</h2>
<h3>Facial recognition by principal components analysis in a nutshell</h3>
<p>We assume that readers are familiar with data analysis by PCA (principal component analysis). We will only present our choices to realise a PCA on faces.</p>
<p>We have a database of 200 images, each image representing one person. Each image is centred, and manually modified, so that the eyes of each person are about at the same place than those of any other person.</p>
<p>The photographs have a size of 360*260 pixels. To recognize a person, we have to project one\'s image, this is to say the vector of pixels representing the person, on the eigenfaces, this is to say, the vectors of pixels representing the eigenfaces. So we have to project a person in the cloud of the pixels. But such a projection implies a correlation matrix of size (360*260)^2. So we work in the cloud of the persons (the correlation matrix is thus of size 200*200) and then we go from the cloud of persons to the cloud of pixels by multiplying left by the matrix of the persons.</p>
<h3>Parallelized algorithms in LibLookLike</h3>
<p>In LibLookLike, four major operations are parallelized:</p><ul>
<li>the multiplication of matrices</li>
<li>the multiplication between a transposed matrix and a matrix</li>
<li>the multiplication of a transposed matrix and itself</li>
<li>the normalization of a matrix.</li>
</ul>
<p>These parallelized algorithms are implemented, as usual, in <a class="el" href="classAlgorithm.html" title="Algorithms class as described in Algorithm. ">Algorithm</a> classes, which use OpenCL kernels to distribute computations on CPUs or GPUs. We will present here three of the four operations above.</p>
<h3>Multiplication of matrices</h3>
<p>The result of the multiplication of two matrices is computed by executing the computation of each element of this matrix in parallel, this is to say, the vectorial products between each row of A and each column of B in the product A*B are executed in parallel.</p>
<h3>Multiplication between a transposed matrix and a matrix</h3>
<p>The multiplication of a transposed matrix and another matrix is computed in the same way than the multiplication of two matrices, except that the vectorial products executed in parallel are between each column of A and each column of B in the product \(\textbf{A}^T * \textbf{B}\), provided that the dimensions of the matrices allow to compute such a product.</p>
<h3>Normalization of a matrix</h3>
<p>The normalisation of a matrix can be executed in respect to the rows, or in respect to the columns. Both are possible in LibLookLike. We will present here the normalisation on the columns. Both normalisations follow the same principle, anyway. To normalise a matrix on the columns, the program executes the computations in parallel for each column : compute the average and variance, and then the new terms of the matrix X as themselves minus the average over the variance. Note that the computation of the variance in the column normalisation in LibLookLike is improved with the Kahan summation algorithm to avoid cancellation.</p>
<p>Later, when computing the matrix \(\textbf{X}^T * \textbf{X}\), the result will be the matrix of covariance. So, at this stage, we will divide the result of the computation of \(\textbf{X}^T * \textbf{X}\) by n, in order to obtain the matrix of correlation. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 18 2014 21:27:24 for liblooklike by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
